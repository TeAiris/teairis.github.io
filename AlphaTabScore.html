<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AlphaTab — AlphaTex + Player + Cursor (Integrated)</title>
  <!-- AlphaTab library (keep your local build path) -->
  <script src="./AlphaTabLib//dist/alphaTab.js"></script>
  
  <style>
    /* ===== styles.css (inlined) ===== */
    /* Handwritten jazz fonts */
    @font-face { font-family: 'MuseJazz'; src: url('fonts/musejazz/MuseJazz.otf') format('opentype'); font-display: swap; }
    @font-face { font-family: 'MuseJazzText'; src: url('fonts/musejazz/MuseJazzText.otf') format('opentype'); font-display: swap; }

    body { margin: 0; font-family: 'MuseJazzText', system-ui, Arial, sans-serif; }
    #sheet { width: 100vw; height: 80vh; position: relative; isolation: isolate; }
    .controls { display:flex; gap:8px; align-items:center; padding:10px; border-top:1px solid #ddd; flex-wrap: wrap; }
    .controls button { padding:6px 10px; }
    .controls .at-loop.active { background: rgba(0,128,0,0.15); border:1px solid rgba(0,128,0,0.35); }
    .spacer { flex:1; }

    /* Cursors / overlays */
    .at-cursor-bar { background: rgba(86,199,222,0.48); }
    .at-selection div{
      background: transparent !important;
      border-top: 3px solid var(--hl-color, rgba(64,64,255,0.7));
      border-bottom: 3px solid var(--hl-color, rgba(64,64,255,0.7));
      border-left: none !important; border-right: none !important; border-radius: 0;
      box-sizing: border-box; pointer-events: none;
    }
    .at-cursor-beat { background: rgba(0,0,0,0.1); width: 3px; }
    .at-highlight * { fill: var(--hl-color, currentColor); stroke: var(--hl-color, currentColor); }

    #sheet .at-viewport, #sheet .at-viewport svg, #sheet svg { position: relative; z-index: 0; }
    #sheet .at-overlay { position: relative; z-index: 1; }
    #sheet .at-selection, #sheet .at-cursor, #sheet .at-cursor-beat, #sheet .at-cursor-bar { background: transparent !important; }

    /* Light/Dark */
    :root { --ui-fg:#111; --ui-bg:#fff; }
    body { background: var(--ui-bg); color: var(--ui-fg); }
    .controls, .controls label, .controls span, .controls button { color: inherit; }

    body.dark { --ui-fg:#fff; --ui-bg:#000; }
    body.dark #sheet { background: transparent; }
    body.dark #sheet svg { background: transparent !important; color:#000 !important; }
    body.dark #sheet svg rect[fill="#ffffff"], body.dark #sheet svg rect[fill="#fff"], body.dark #sheet svg rect[fill="white"] { fill: transparent !important; }
    body.dark .controls button { background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.25); }
    body.dark input[type="range"]::-webkit-slider-thumb,
    body.dark input[type="range"]::-moz-range-thumb { background:#fff; }
  </style>
</head>
<body>
  <div id="sheet"></div>

  <div class="controls">
    <!-- transport -->
    <button id="play" disabled>Play</button>
    <button id="stop" disabled>Stop</button>
    <button id="loop" class="at-loop" aria-pressed="false" title="Toggle Loop (L)">Loop</button>
    <button id="prevNote" title="Highlight Previous Note">Prev Note</button>
    <button id="nextNote" title="Highlight Next Note">Next Note</button>
    <span id="status">Loading soundfont… 0%</span>
    &nbsp; SoundFont:
    <select id="sfSelect" title="Choose SoundFont">
      <option value="local" selected>Local (Mallets_GM.sf2)</option>
      <option value="cdn">CDN Sonivox</option>
    </select>
    &nbsp; Metronome:
    <label><input id="metroToggle" type="checkbox"> Enable</label>
    <label>Vol <input id="metroVol" type="range" min="0" max="1" step="0.05" value="0" style="width:90px;"></label>
    <span class="spacer"></span>
    <button id="btnSetStart" title="Set playbackRange start = current tick">Set Start = ct</button>
    <button id="btnSetEnd" title="Set playbackRange end = current tick">Set End = ct</button>
    &nbsp; Early(ms):
    <input id="earlyMs" type="range" min="0" max="30" value="5" style="width:120px;">
    <span id="earlyVal" class="mono">5</span>
    &nbsp; Delay at loop end:
    <input id="lateDelay" type="range" min="0" max="50" step="1" value="0" style="width:120px;">
    <span id="lateDelayVal" class="mono">0</span> ms

    <!-- tempo + layout/opacity -->
    <label>Tempo:
      <input id="tempo" type="range" min="40" max="220" value="110" style="width:120px;">
      <span id="tempoVal">110</span> BPM
    </label>
    <label>Note Opacity:
      <input id="opacity" type="range" min="0" max="1" step="0.05" value="0.05" style="width:90px;">
      <span id="opacityVal">0.05</span>
    </label>
    <label>Chord Spacing (top):
      <input id="chordSpace" type="range" min="0" max="30" step="1" value="12" style="width:110px;">
      <span id="chordVal">12px</span>
    </label>
    <label>Dynamics Spacing (bottom):
      <input id="dynSpace" type="range" min="0" max="30" step="1" value="16" style="width:110px;">
      <span id="dynVal">16px</span>
    </label>

    <!-- highlight assist + HSV -->
    <label style="margin-left:12px;">
      <input id="hlAssist" type="checkbox"> Loop Selection Assist
    </label>
    <span class="hsv-controls" style="margin-left:12px;">
      <label title="Hue (0–360)" style="display:inline;">H:
        <input id="hlH" type="range" min="0" max="360" value="210" style="width:60px;">
        <span id="hlHVal">210</span>
      </label>
      <label title="Saturation (0–100%)" style="display:inline; margin-left:8px;">S:
        <input id="hlS" type="range" min="0" max="100" value="70" style="width:60px;">
        <span id="hlSVal">70</span>%
      </label>
      <label title="Value/Brightness (0–100%)" style="display:inline; margin-left:8px;">V:
        <input id="hlV" type="range" min="0" max="100" value="80" style="width:60px;">
        <span id="hlVVal">80</span>%
      </label>
    </span>

    <!-- theme -->
    <label style="margin-left:12px;">
      <input id="darkMode" type="checkbox"> Dark mode
    </label>

    <!-- NEW: Transpose/Key controls -->
    <span style="margin-left:12px;">Transpose:
      <button id="tDown" title="Transpose down">−</button>
      <button id="tUp" title="Transpose up">+</button>
      <button id="tReset" title="Reset transpose">Reset</button>
      <span id="transposeVal">0</span> st
    </span>
    <label title="Update visible key signature when transposing">
      <input id="keySigToggle" type="checkbox" checked> Key Sig
    </label>
    <label title="Prefer flats for enharmonic keys (Db/Gb/Cb); when off uses C#/F#/B">
      <input id="enhToggle" type="checkbox"> Prefer flats
    </label>

    <!-- debug -->
    <span id="pos">00:00 / 00:00</span>
    <span id="dbg" style="font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; margin-left:12px; opacity:0.85;">
      PR: – / – | Loop: – / – | ct: – | seeks: 0
    </span>
  </div>

  <script>
  (() => {
    /* =========================
       GLOBALS (config + state)
       ========================= */
    const CONFIG = {
      SOUNDFONT_URL: "./AlphaTabLib//dist/soundfont/mallets.sf2",
      SOUNDFONT_CDN: "./AlphaTabLib//dist/soundfont/sonivox.sf2",
      DEFAULT_BPM: 110
    };


    //Next/Previous Note Highlighting
    let highlightedNoteIdx = -1; // -1 means nothing selected
    let highlightNotesList = [];  

    // Runtime state grouped up-front (C#-style “fields”)
    const STATE = {
      api: null,

      // visuals & theme
      isDark: false,
      normalNoteDimFactor: 0.05, // 0 = black/white, 1 = full color
      builtinHighlightOn: false,

      // timing
      currentBpm: CONFIG.DEFAULT_BPM,

      // tick cache / accents
      tickCacheReady: false,
      tickHint: null,
      pendingAccentOnWarm: false,


      // transpose / keys
      transposeSemis: parseInt(localStorage.getItem('notationTranspose') || '0', 10) || 0,
      keySigOn: (localStorage.getItem('keySigToggle') !== '0'),
      preferFlats: (localStorage.getItem('enhPreferFlats') === '1'),

      // last accent
      lastBeatAccented: null
    };

    /* =========================
       DOM references
       ========================= */
    const container = document.getElementById('sheet');
    const btnPlay = document.getElementById('play');
    const btnStop = document.getElementById('stop');
    const status = document.getElementById('status');
    const btnLoop = document.getElementById('loop');
    const tempoSlider = document.getElementById('tempo');
    const tempoVal = document.getElementById('tempoVal');
    const pos = document.getElementById('pos');
    const opacitySlider = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    const chordSpace = document.getElementById('chordSpace');
    const chordVal = document.getElementById('chordVal');
    const dynSpace = document.getElementById('dynSpace');
    const dynVal = document.getElementById('dynVal');
    const hlH = document.getElementById('hlH'), hlHVal = document.getElementById('hlHVal');
    const hlS = document.getElementById('hlS'), hlSVal = document.getElementById('hlSVal');
    const hlV = document.getElementById('hlV'), hlVVal = document.getElementById('hlVVal');
    const darkMode = document.getElementById('darkMode');
    const hlAssist = document.getElementById('hlAssist');
    const dbg = document.getElementById('dbg');

    // NEW
    const tDown = document.getElementById('tDown');
    const tUp = document.getElementById('tUp');
    const tReset = document.getElementById('tReset');
    const transposeVal = document.getElementById('transposeVal');
    const keySigToggle = document.getElementById('keySigToggle');
    const enhToggle = document.getElementById('enhToggle');

    // SoundFont & Metronome controls
    const sfSelect = document.getElementById('sfSelect');
    const metroToggle = document.getElementById('metroToggle');
    const metroVol = document.getElementById('metroVol');

    // Get your buttons
const btnPrevNote = document.getElementById('prevNote');
const btnNextNote = document.getElementById('nextNote');

// Previous Note button handler
if (btnPrevNote) btnPrevNote.onclick = () => {
  if (highlightNotesList.length === 0) return;
  let idx = highlightedNoteIdx <= 0 ? highlightNotesList.length - 1 : highlightedNoteIdx - 1;
  highlightNoteAt(idx);
};

// Next Note button handler
if (btnNextNote) btnNextNote.onclick = () => {
  if (highlightNotesList.length === 0) return;
  let idx = highlightedNoteIdx < 0 ? 0 : highlightedNoteIdx + 1;
  if (idx >= highlightNotesList.length) idx = 0;
  highlightNoteAt(idx);
};

    /* =========================
       AlphaTab init + TEX
       ========================= */
    const TEX_TEMPLATE = (bpm) => `
\\tempo ${bpm} .
\\track "Marimba"
\\instrument marimba
:4 (C4){ch "Cmaj7"} D4 E4 c3{ beam down } | (G4){ch "Dm7"} A4 B4 C5 |
:4 (C5){ch "G7"} B4 A4 G4 | (F4){ch "Cmaj7"} E4 D4 C4 |
:8 (C4){ch "Fmaj7"} D4 E4 F4 G4 A4 B4 C5 | (E4){ch "Em7"} F4 G4 A4 B4 C5 D5 E5 |
:8 (A4){ch "A7"} G4 F4 E4 D4 C4 B3 A3 | :4 (G4){ch "G7"} F4 E4 D4`;

    const api = STATE.api = new alphaTab.AlphaTabApi(container, {
      core: { tex: true },
      display: {
        resources: {
          titleFont: "32px 'MuseJazzText', serif",
          subTitleFont: "20px 'MuseJazzText', serif",
          wordsFont: "15px 'MuseJazzText', serif",
          copyrightFont: "11px 'MuseJazzText', serif",
          directionsFont: "16px 'MuseJazzText', serif",
          markerFont: "bold 14px 'MuseJazzText', serif",
          effectFont: "italic 12px 'MuseJazzText', serif",
          graceFont: "11px 'MuseJazzText', serif",
          barNumberFont: "12px 'MuseJazzText', serif",
          timerFont: "12px 'MuseJazzText', serif",
          fingeringFont: "12px 'MuseJazzText', serif",
          inlineFingeringFont: "12px 'MuseJazzText', serif",
          tablatureFont: "13px 'MuseJazzText', serif",
          numberedNotationFont: "14px 'MuseJazzText', serif",
          numberedNotationGraceFont: "12px 'MuseJazzText', serif",
          fretboardNumberFont: "12px 'MuseJazzText', serif"
        },
        effectStaffPaddingTop: 16,
        notationStaffPaddingBottom: 14,
        effectStaffPaddingBottom: 12,
        notationStaffPaddingTop: 10
      },
      player: {
        enablePlayer: true,
        enableCursor: true,
        enableElementHighlighting: false,
        soundFont: CONFIG.SOUNDFONT_URL,
        scrollElement: container,
        schedulerLookAhead: 20,
        reverb: {
        enabled: true,
        roomSize: 1,  // 0.0 - 1.0
        damping: 0.2,   // 0.0 - 1.0
        width: 0.8,     // 0.0 - 1.0
        level: 0.9      // 0.0 - 1.0 (amount of effect applied)
      }
        
      }
    });

    try { api.isLooping = false; } catch(_) {}
    // SoundFont preference
    const savedSf = localStorage.getItem('sfChoice') || 'local';
    if (sfSelect) sfSelect.value = savedSf;
    const applySoundFontChoice = (choice) => {
      const url = choice === 'cdn' ? CONFIG.SOUNDFONT_CDN : CONFIG.SOUNDFONT_URL;
      try {
        if (typeof api.loadSoundFontFromUrl === 'function') {
          api.loadSoundFontFromUrl(url);
        } else {
          api.settings.player.soundFont = url;
          api.updateSettings();
          api.render();
        }
      } catch (e) { console.warn('applySoundFontChoice failed:', e); }
    };
    applySoundFontChoice(savedSf);
    const renderScoreWithBpm = (bpm) => { STATE.currentBpm = bpm; api.tex(TEX_TEMPLATE(STATE.currentBpm)); };

    /* =========================
       Helpers (colors, ticks, etc.)
       ========================= */
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const debounce = (fn, delay) => { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), delay); }; };

    // ---- Ensure MIDI is rebuilt after transpose so audio updates without needing tempo nudge
    const regenerateMidi = (keepPlaying = true) => {
      try {
        const wasPlaying = api?.player?.state === alphaTab.synth.PlayerState.Playing;
        const ct = typeof api.tickPosition === 'number' ? api.tickPosition : 0;
        const pr = api.playbackRange ? { ...api.playbackRange } : null;

        // pause while we rebuild (only if we intend to resume)
        try { if (keepPlaying && wasPlaying) api.pause(); } catch {}

        const onLoaded = () => {
          try { api.midiLoaded.off(onLoaded); } catch {}
          try { if (pr) api.playbackRange = pr; } catch {}
          try { api.tickPosition = ct; } catch {}
          if (keepPlaying && wasPlaying) {
            try { api.play(); } catch {}
          }
        };
        try { api.midiLoaded.on(onLoaded); } catch {}

        // trigger regeneration
        try { api.loadMidiForScore(); } catch (e) { console.warn('loadMidiForScore failed:', e); }
      } catch (e) {
        console.warn('regenerateMidi failed:', e);
      }
    };

    // Debounced variants: resume only if we were playing vs. silent (no auto-play)
    const regenMidiDebouncedPlay   = debounce(() => regenerateMidi(true),  75);
    const regenMidiDebouncedSilent = debounce(() => regenerateMidi(false), 75);
    const fmtTime = (ms) => { const s = Math.floor(ms/1000), m = Math.floor(s/60), r = s - m*60; return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`; };

    const BW_COLORS = ['#FF0000','#FF6600','#FF9900','#FFCC00','#FFFF00','#00FF00','#00CCFF','#0066FF','#6600FF','#9900CC','#CC0099','#FF3399'];
    const hexToRgb = (hex) => { const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : { r:0,g:0,b:0 }; };
    const rgbToHex = (r,g,b) => '#' + [r,g,b].map(v => clamp(v,0,255).toString(16).padStart(2,'0')).join('');
    const hsvToRgb = (h,s,v) => { h=((h%360)+360)%360; s=clamp(s,0,100)/100; v=clamp(v,0,100)/100; const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c; let r=0,g=0,b=0;
      if (h<60){r=c;g=x;b=0;} else if (h<120){r=x;g=c;b=0;} else if (h<180){r=0;g=c;b=x;} else if (h<240){r=0;g=x;b=c;} else if (h<300){r=x;g=0;b=c;} else {r=c;g=0;b=x;}
      return { r: Math.round((r+m)*255), g: Math.round((g+m)*255), b: Math.round((b+m)*255) }; };
    const hsvToHex = (h,s,v) => { const {r,g,b}=hsvToRgb(h,s,v); return rgbToHex(r,g,b); };
    const pcColor = (midi) => { const pc = ((midi % 12) + 12) % 12; return BW_COLORS[pc] || '#000000'; };
    const setHighlightColor = (hex) => document.documentElement.style.setProperty('--hl-color', hex);
    const getStaticHlHex = () => hsvToHex(parseFloat(hlH.value)||0, parseFloat(hlS.value)||0, parseFloat(hlV.value)||0);

    const getTickCache = () => api.tickCache ?? api.boundsLookup ?? null;
    function ticksPerMs(){
      const tc = getTickCache();
      const durMs = api?.player?.endTime ?? api?.score?.playTime ?? null;
      const durTicks = api?.score?.duration ?? null;
      if (tc && typeof tc.timeToTick === 'function' && durMs != null && durTicks != null) {
        const tick0 = tc.timeToTick(0), tick1 = tc.timeToTick(1);
        return Math.max(1, tick1 - tick0);
      }
      if (durMs && durTicks) return durTicks / durMs;
      return 1;
    }
    function msToTicks(ms){ return Math.max(1, Math.round(ticksPerMs() * ms)); }
    function ticksToMs(t){ const k = ticksPerMs(); return Math.round(t / k); }

    const getTrackSet = () => {
      const t = api?.score?.tracks || [];
      const idx = new Set(); for (let i = 0; i < t.length; i++) idx.add(i);
      if (idx.size === 0) idx.add(0); return idx;
    };


    

    /* =========================
       Theme / notational styles
       ========================= */
    const applyDarkNotationalStyles = (score, dark) => {
      try {
        const A = alphaTab.model;
        const WHITE = A.Color.fromJson('#FFFFFF');

        if (dark) {
          score.style = new A.ScoreStyle();
          const SS = A.ScoreSubElement;
          [SS.Title,SS.SubTitle,SS.Artist,SS.Album,SS.Words,SS.Music,SS.WordsAndMusic,SS.Transcriber,SS.Copyright,SS.CopyrightSecondLine,SS.ChordDiagramList]
            .forEach(k => { if (k !== undefined) score.style.colors.set(k, WHITE); });
          for (const track of score.tracks) {
            track.style = new A.TrackStyle();
            const TS = A.TrackSubElement;
            [TS.TrackName, TS.BracesAndBrackets, TS.SystemSeparator, TS.StringTuning]
              .forEach(k => { if (k !== undefined) track.style.colors.set(k, WHITE); });
            for (const staff of track.staves) for (const bar of staff.bars) {
              if (!bar.style) bar.style = new A.BarStyle();
              const BSb = A.BarSubElement;
              [BSb.StandardNotationBarNumber, BSb.StandardNotationBarLines, BSb.StandardNotationClef,
               BSb.StandardNotationKeySignature, BSb.StandardNotationTimeSignature, BSb.StandardNotationStaffLine]
               .forEach(k => { if (k !== undefined) bar.style.colors.set(k, WHITE); });
              for (const voice of bar.voices) for (const beat of voice.beats) {
                if (!beat.style) beat.style = new A.BeatStyle();
                const BE = A.BeatSubElement;
                [BE.Effects, BE.StandardNotationEffects].forEach(k => {
                  if (k !== undefined) beat.style.colors.set(k, WHITE);
                });
              }
            }
          }
        } else {
          // fully reset all styles so colors are not stuck from dark mode
          try { score.style = null; } catch {}
          for (const track of score.tracks) {
            try { track.style = null; } catch {}
            for (const staff of track.staves) for (const bar of staff.bars) {
              try { bar.style = null; } catch {}
              for (const voice of bar.voices) {
                for (const beat of voice.beats) {
                  try { beat.style = null; } catch {}
                  for (const n of beat.notes || []) { try { n.style = null; } catch {} }
                }
              }
            }
          }
        }
      } catch {}
    };

    const colorSets = (() => {
      const A = alphaTab.model;
      const NS = A.NoteSubElement, BS = A.BeatSubElement;
      const NOTE_KEYS_ALL = [
        NS.StandardNotationNoteHead, NS.StandardNotationAccidentals, NS.StandardNotationEffects,
        NS.GuitarTabFretNumber, NS.GuitarTabEffects, NS.SlashNoteHead, NS.SlashEffects,
        NS.NumberedNumber, NS.NumberedAccidentals, NS.NumberedEffects,
        NS.StandardNotationLedgerLines, NS.StandardNotationLedgerLine, NS.LedgerLines
      ].filter(Boolean);
      const BEAT_KEYS_BASELINE = [
        BS.StandardNotationStem, BS.StandardNotationFlags, BS.StandardNotationBeams, BS.StandardNotationTuplet,
        BS.StandardNotationEffects, BS.StandardNotationRests, BS.StandardNotationGraceBeams, BS.StandardNotationGraceFlags,
        BS.GuitarTabStem, BS.GuitarTabFlags, BS.GuitarTabBeams, BS.GuitarTabTuplet, BS.GuitarTabEffects,
        BS.StandardNotationLedgerLines
      ].filter(Boolean);
      const BEAT_KEYS_ACCENT = BEAT_KEYS_BASELINE.filter(k =>
        k !== BS.StandardNotationBeams && k !== BS.GuitarTabBeams && k !== BS.StandardNotationGraceBeams && k !==  BS.StandardNotationStem, 
      );
      return { NOTE_KEYS_ALL, BEAT_KEYS_BASELINE, BEAT_KEYS_ACCENT };
    })();

    const dimHex = (hex, factor=STATE.normalNoteDimFactor) => {
      const {r,g,b} = hexToRgb(hex);
      const target = STATE.isDark ? {r:255,g:255,b:255} : {r:0,g:0,b:0};
      return rgbToHex(
        Math.round(r*factor + target.r*(1-factor)),
        Math.round(g*factor + target.g*(1-factor)),
        Math.round(b*factor + target.b*(1-factor))
      );
    };

    const beatSignature = (beat) => (beat?.notes || []).map(n => (typeof n?.realValue === 'number' ? n.realValue : 'x')).join(',');
    const beatTopColorHex = (beat) => {
      let top = null;
      for (const n of beat?.notes || []) {
        if (typeof n?.realValue === 'number' && (top === null || n.realValue > top.realValue)) top = n;
      }
      return top ? pcColor(top.realValue) : '#000000';
    };
    const findBeatInScore = (score, targetBeat) => {
      if (!score || !targetBeat) return null;
      const sig = beatSignature(targetBeat);
      if (!sig) return null;
      for (const track of score.tracks || []) for (const staff of track.staves || [])
      for (const bar of staff.bars || []) for (const voice of bar.voices || [])
      for (const beat of voice.beats || []) {
        if ((beat?.notes?.length || 0) === (targetBeat.notes?.length || 0) && beatSignature(beat) === sig) return beat;
      }
      return null;
    };

    const recolorBeat = (beat) => {
      if (!STATE.USE_INLINE_COLORING) return;
      try {
        const A = alphaTab.model, K = colorSets;
        const dim = A.Color.fromJson(dimHex(beatTopColorHex(beat), STATE.normalNoteDimFactor));
        if (!beat.style) beat.style = new A.BeatStyle();
        for (const k of K.BEAT_KEYS_BASELINE) beat.style.colors.set(k, dim);
        for (const n of beat.notes || []) {
          if (typeof n.realValue !== 'number') continue;
          const nhCol = A.Color.fromJson(dimHex(pcColor(n.realValue), STATE.normalNoteDimFactor));
          if (!n.style) n.style = new A.NoteStyle();
          for (const k of K.NOTE_KEYS_ALL) n.style.colors.set(k, nhCol);
        }
      } catch {}
    };
    const accentBeat = (beat) => {
      if (!STATE.USE_INLINE_COLORING) return;
      if (!beat) return;
      const A = alphaTab.model, K = colorSets;
      const fullHex = beatTopColorHex(beat);
      const fullCol = A.Color.fromJson(fullHex);
      if (!beat.style) beat.style = new A.BeatStyle();
      for (const k of K.BEAT_KEYS_ACCENT) beat.style.colors.set(k, fullCol);
      for (const n of (beat.notes || [])) {
        if (typeof n.realValue !== 'number') continue;
        const nFullCol = A.Color.fromJson(pcColor(n.realValue));
        if (!n.style) n.style = new A.NoteStyle();
        for (const k of K.NOTE_KEYS_ALL) n.style.colors.set(k, nFullCol);
      }
    };
    const colorScoreByPitch = (score) => {
      if (!STATE.USE_INLINE_COLORING) return;
      try {
        const A = alphaTab.model, K = colorSets;
        for (const track of score?.tracks || []) for (const staff of track.staves || [])
        for (const bar of staff.bars || []) for (const voice of bar.voices || [])
        for (const beat of voice.beats || []) {
          const topHex = beatTopColorHex(beat);
          const stemHex = dimHex(topHex, STATE.normalNoteDimFactor);
          const stemCol = A.Color.fromJson(stemHex);
          if (!beat.style) beat.style = new A.BeatStyle();
          for (const k of K.BEAT_KEYS_BASELINE) beat.style.colors.set(k, stemCol);
          for (const n of beat.notes || []) {
            if (typeof n.realValue !== 'number') continue;
            const nh = A.Color.fromJson(dimHex(pcColor(n.realValue), STATE.normalNoteDimFactor));
            if (!n.style) n.style = new A.NoteStyle();
            for (const k of K.NOTE_KEYS_ALL) n.style.colors.set(k, nh);
          }
        }
      } catch (e) { console.warn('colorScoreByPitch failed:', e); }
    };

    /* =========================
       Built-in highlight assist
       ========================= */
    function setBuiltinHighlighting(on) {
      STATE.builtinHighlightOn = !!on;
      const s = api.settings || {};
      s.player = s.player || {};
      s.player.enableElementHighlighting = STATE.builtinHighlightOn;
      try { api.updateSettings(s); api.render(); } catch (_) {}
    }
    STATE.USE_INLINE_COLORING = true;

    // ---- Time/Tick conversion helpers (LoopTest compatible)
    function ticksPerMs(){
      const tc = api.tickCache ?? api.boundsLookup ?? null;
      const durMs = api?.player?.endTime ?? api?.score?.playTime ?? null;
      const durTicks = api?.score?.duration ?? null;
      if (tc && typeof tc.timeToTick === 'function' && durMs != null && durTicks != null) {
        const t0 = 0, t1 = 1; const tick0 = tc.timeToTick(t0); const tick1 = tc.timeToTick(t1);
        return Math.max(1, tick1 - tick0);
      }
      if (durMs && durTicks) return durTicks / durMs;
      return 1;
    }
    function msToTicks(ms){ return Math.max(1, Math.round(ticksPerMs() * ms)); }
    function ticksToMs(t){ const k = ticksPerMs(); return Math.round(t / k); }
    function currentTick() {
      return (typeof api.tickPosition === 'number') ? api.tickPosition : (typeof api.player?.currentTick === 'number' ? api.player.currentTick : null);
    }

    // ---- PlaybackRange helpers
    function getPlaybackRangeTicks() {
      const pr = api.playbackRange || api.player?.playbackRange || null;
      if (!pr) return { s:null, e:null, src:'none' };
      if (typeof pr.startTick === 'number' && typeof pr.endTick === 'number') return { s: pr.startTick, e: pr.endTick, src:'playbackRange[ticks]' };
      if (typeof pr.tickStart === 'number' && typeof pr.tickEnd === 'number') return { s: pr.tickStart, e: pr.tickEnd, src:'playbackRange[tickStart/tickEnd]' };
      const msStart = (typeof pr.startTime === 'number') ? pr.startTime : (typeof pr.msStart === 'number' ? pr.msStart : null);
      const msEnd   = (typeof pr.endTime === 'number') ? pr.endTime   : (typeof pr.msEnd === 'number'   ? pr.msEnd   : null);
      if (msStart != null && msEnd != null) {
        const tc = api.tickCache ?? api.boundsLookup ?? null;
        if (tc && typeof tc.timeToTick === 'function') return { s: tc.timeToTick(msStart), e: tc.timeToTick(msEnd), src:'playbackRange[ms->tick]' };
        const durMs = api?.player?.endTime ?? api?.score?.playTime ?? null;
        const durTicks = api?.score?.duration ?? null;
        if (durMs && durTicks) { const ratio = durTicks / durMs; return { s: Math.round(msStart * ratio), e: Math.round(msEnd * ratio), src:'playbackRange[estimate]' }; }
      }
      return { s:null, e:null, src:'playbackRange[unknown]' };
    }

    // ---- Loop state (LoopTest compatible)
    let loopEnabled = false;
    let loopStartTick = null;
    let loopEndTick = null;
    let seeks = 0;
    let lastSeekAt = 0;
    let EARLY_MS = 5;
    let LOOP_SEEK_EARLY_TICKS = msToTicks(EARLY_MS);
    let lateDelayMs = 0;

    // wire sliders
    const earlyMs = document.getElementById('earlyMs');
    const earlyVal = document.getElementById('earlyVal');
    const lateDelay = document.getElementById('lateDelay');
    const lateDelayVal = document.getElementById('lateDelayVal');
    if (earlyMs && earlyVal){ earlyMs.addEventListener('input', ()=>{ EARLY_MS = parseInt(earlyMs.value,10)||0; earlyVal.textContent = EARLY_MS; LOOP_SEEK_EARLY_TICKS = msToTicks(EARLY_MS); updateDebug('(early='+EARLY_MS+'ms)'); }); }
    if (lateDelay && lateDelayVal){ lateDelay.addEventListener('input', ()=>{ lateDelayMs = parseInt(lateDelay.value,10)||0; lateDelayVal.textContent = lateDelayMs; }); }

    function setLoopFromActiveRange() {
      let s=null, e=null, used='none';
      const pr = getPlaybackRangeTicks();
      if (typeof pr.s === 'number' && typeof pr.e === 'number' && pr.e > pr.s) { s = pr.s; e = pr.e; used = pr.src; }
      else if (typeof api.score?.duration === 'number') { s = 0; e = api.score.duration; used = 'score.duration'; }
      loopStartTick = s; loopEndTick = e; updateDebug(`(setLoop via ${used})`);
      return (loopStartTick != null && loopEndTick != null);
    }

    function updateDebug(extra=''){
      const dbg = document.getElementById('dbg'); if (!dbg) return;
      const pr = getPlaybackRangeTicks();
      const parts = [];
      parts.push(`PR: ${pr.s ?? '–'} / ${pr.e ?? '–'}`);
      parts.push(`Loop: ${loopStartTick ?? '–'} / ${loopEndTick ?? '–'}`);
      parts.push(`ct: ${currentTick() ?? '–'}`);
      parts.push(`seeks: ${seeks}`);
      if (extra) parts.push(extra);
      dbg.textContent = parts.join(' | ');
    }

    function ensureSeekToLoopStart() {
      const now = performance.now ? performance.now() : Date.now();
      if (now - lastSeekAt < 15) return;
      lastSeekAt = now;
      try {
        if (currentTick() >= loopEndTick) return;
        // LoopTest behavior: jump via tickPosition and keep playing
        api.tickPosition = loopStartTick ?? 0;
        if (api.player && api.player.state !== alphaTab.synth.PlayerState.Playing) { api.play(); }
        try { api.scrollToCursor(); } catch(_) {}
        seeks++; updateDebug('(seek)');
      } catch {}
    }

    // buttons to set playbackRange endpoints
    const btnSetStart = document.getElementById('btnSetStart');
    const btnSetEnd   = document.getElementById('btnSetEnd');
    if (btnSetStart) btnSetStart.onclick = () => {
      const ct = currentTick(); if (ct == null) return;
      const pr = getPlaybackRangeTicks();
      const s = ct, e = (typeof pr.e === 'number' ? pr.e : (api.score?.duration ?? ct+1));
      api.playbackRange = { startTick: Math.max(0, Math.min(s, e-1)), endTick: Math.max(s+1, e) };
      if (loopEnabled) setLoopFromActiveRange();
      updateDebug('(start=ct)');
    };
    if (btnSetEnd) btnSetEnd.onclick = () => {
      const ct = currentTick(); if (ct == null) return;
      const pr = getPlaybackRangeTicks();
      const s = (typeof pr.s === 'number' ? pr.s : 0), e = ct;
      api.playbackRange = { startTick: Math.max(0, Math.min(s, e-1)), endTick: Math.max(s+1, e) };
      if (loopEnabled) setLoopFromActiveRange();
      updateDebug('(end=ct)');
    };

    // toggle loop using the same button id as HTML (#loop)
    //const btnLoop = document.getElementById('loop');
    if (btnLoop){
      btnLoop.addEventListener('click', ()=>{
        loopEnabled = !loopEnabled;
        btnLoop.classList.toggle('active', loopEnabled);
        btnLoop.setAttribute('aria-pressed', loopEnabled ? 'true' : 'false');
        if (loopEnabled) setLoopFromActiveRange(); else { loopStartTick = loopEndTick = null; }
        try { api.isLooping = false; } catch(_) {}
        updateDebug(loopEnabled ? '(loop:on)' : '(loop:off)');
      });
    }
    
    

    // hook AlphaTab events to drive loop
    api.playerStateChanged.on(e => {
      const playing = e.state === alphaTab.synth.PlayerState.Playing;
      document.getElementById('play').textContent = playing ? 'Pause' : 'Play';
      if (playing && loopEnabled && loopStartTick != null) { ensureSeekToLoopStart(); }
      updateDebug('(state)');
    });

    api.playerPositionChanged.on(e => {
      // keep your existing time display if present
      const pos = document.getElementById('pos');
      if (pos) pos.textContent = `${String(Math.floor(e.currentTime/60000)).padStart(2,'0')}:${String(Math.floor((e.currentTime/1000)%60)).padStart(2,'0')} / ${String(Math.floor(e.endTime/60000)).padStart(2,'0')}:${String(Math.floor((e.endTime/1000)%60)).padStart(2,'0')}`;
      if (loopEnabled && loopStartTick != null && loopEndTick != null) {
        const ct = e.currentTick;
        if (typeof ct === 'number' && ct >= (loopEndTick - LOOP_SEEK_EARLY_TICKS)) { ensureSeekToLoopStart(); }
      }
      updateDebug();
    });

    api.playbackRangeChanged?.on?.(()=>{ if (loopEnabled) setLoopFromActiveRange(); updateDebug('(PR changed)'); });

    api.playerFinished.on(()=>{
      if (!loopEnabled || loopStartTick == null) return;
      setTimeout(()=>{ api.tickPosition = loopStartTick; api.play(); seeks++; updateDebug('(finished->restart)'); }, lateDelayMs);
    });

    api.scoreLoaded.on(()=>{ setLoopFromActiveRange(); LOOP_SEEK_EARLY_TICKS = msToTicks(EARLY_MS); updateDebug(`(recalc early=${LOOP_SEEK_EARLY_TICKS}t ~${ticksToMs(LOOP_SEEK_EARLY_TICKS)}ms)`); 


    });
    api.midiLoaded.on(()=>{ LOOP_SEEK_EARLY_TICKS = msToTicks(EARLY_MS); updateDebug(`(recalc early=${LOOP_SEEK_EARLY_TICKS}t ~${ticksToMs(LOOP_SEEK_EARLY_TICKS)}ms)`); });

    /* =========================
       Strict key mapping + enharmonics
       ========================= */
    // Sharps preference: C#, F#, B
    const PC_TO_KS_SHARPS = { 0:0, 1:7, 2:2, 3:-3, 4:4, 5:-1, 6:6, 7:1, 8:-4, 9:3, 10:-2, 11:5 };
    // Flats  preference: Db, Gb, Cb
    const PC_TO_KS_FLATS  = { 0:0, 1:-5, 2:2, 3:-3, 4:4, 5:-1, 6:-6, 7:1, 8:-4, 9:3, 10:-2, 11:-7 };

    const clampSemis = (val) => Math.max(-12, Math.min(12, Math.trunc(val)));
    const reflectTransposeUI = (val) => { if (transposeVal) transposeVal.textContent = String(val); };

    function computePreferredKSAfterTranspose(semi){
      const n = ((semi % 12) + 12) % 12; // normalize negatives
      const map = STATE.preferFlats ? PC_TO_KS_FLATS : PC_TO_KS_SHARPS;
      return map[n] ?? 0;
    }
    function setScoreKeySignatureVal(val){
      try {
        const score = api.score; if (!score) return;
        let current = (typeof score.keySignature === 'number') ? score.keySignature : null;
        if (current == null && Array.isArray(score.masterBars) && score.masterBars.length) {
          current = score.masterBars[0].keySignature;
        }
        if (current === val) return;
        if (typeof score.keySignature === 'number') score.keySignature = val;
        if (Array.isArray(score.masterBars)){
          for (const mb of score.masterBars){ mb.keySignature = val; }
        }
        try { api.updateSyncPoints(); } catch(_) {}
      } catch(e){ console.warn('setScoreKeySignatureVal failed', e); }
    }

    function applyNotationTranspose(semi){
      const clamped = clampSemis(semi);
      if (clamped !== STATE.transposeSemis){
        STATE.transposeSemis = clamped;
        try { localStorage.setItem('notationTranspose', String(STATE.transposeSemis)); } catch {}
      }
      reflectTransposeUI(STATE.transposeSemis);

      // 1) Playback transpose (fast param change)
      try {
        const tracks = Array.isArray(api.tracks) ? api.tracks : [];
        if (tracks.length > 0 && typeof api.changeTrackTranspositionPitch === 'function') {
          api.changeTrackTranspositionPitch(tracks, STATE.transposeSemis);
        }
      } catch (e) { console.warn('transpose playback failed', e); }

      // 2) Notation transpose + optional key signature change
      try {
        const s = api.settings || (api.settings = {});
        s.notation = s.notation || {};

        const rendered = (api.tracks && api.tracks.length) ? api.tracks.length : 0;
        const total    = (api.score && api.score.tracks && api.score.tracks.length) ? api.score.tracks.length : 0;
        const nTracks  = Math.max(rendered, total, 1);
        const next     = Array.from({ length: nTracks }, () => STATE.transposeSemis);
        const prev     = Array.isArray(s.notation.transpositionPitches) ? s.notation.transpositionPitches : [];
        const sameArr  = prev.length === next.length && prev.every((v,i)=>v===next[i]);

        s.notation.transposeKeySignatures = !!STATE.keySigOn;
        if (!sameArr) s.notation.transpositionPitches = next;

        api.updateSettings();

        if (s.notation.transposeKeySignatures){
          const targetKS = computePreferredKSAfterTranspose(STATE.transposeSemis);
          setScoreKeySignatureVal(targetKS);
        }
        try { api.render(); } catch {}
      } catch (e) { console.warn('transpose notation failed', e); }

      // 3) Rebuild MIDI to reflect the new transpose immediately without needing a tempo nudge.
      //    If we were playing, resume automatically; if paused, do not auto-start.
      if (api?.player) {
        const wasPlaying = api.player.state === alphaTab.synth.PlayerState.Playing;
        if (wasPlaying) {
          regenMidiDebouncedPlay();
        } else {
          regenMidiDebouncedSilent();
        }
      }
    }

    /* =========================
       UI wiring
       ========================= */
    // theme
    (function initTheme(){
      const saved = localStorage.getItem('alphatabTheme');
      STATE.isDark = saved ? (saved === 'dark') : false;
      darkMode.checked = STATE.isDark;
      document.body.classList.toggle('dark', STATE.isDark);
    })();
    darkMode.addEventListener('change', () => {
      STATE.isDark = !!darkMode.checked;
      document.body.classList.toggle('dark', STATE.isDark);
      localStorage.setItem('alphatabTheme', STATE.isDark ? 'dark' : 'light');
      try {
        if (api?.score) {
          applyDarkNotationalStyles(api.score, STATE.isDark);
          colorScoreByPitch(api.score);
          api.updateSettings();
          api.render();
        }
      } catch {}
    });
    // SoundFont selector wiring
    if (sfSelect) {
      sfSelect.addEventListener('change', () => {
        const choice = sfSelect.value;
        try { localStorage.setItem('sfChoice', choice); } catch {}
        applySoundFontChoice(choice);
      });
    }

    // Metronome
    const savedMetroVol = parseFloat(localStorage.getItem('metroVol') || '0');
    if (!isNaN(savedMetroVol)) {
      metroVol.value = String(savedMetroVol);
      try { api.metronomeVolume = savedMetroVol; } catch {}
      metroToggle.checked = savedMetroVol > 0;
    }

    metroToggle.addEventListener('change', () => {
      const on = !!metroToggle.checked;
      const vol = on ? (parseFloat(metroVol.value) || 0.5) : 0;
      try { api.metronomeVolume = vol; } catch {}
      try { localStorage.setItem('metroVol', String(vol)); } catch {}
      if (on && vol === 0) { metroVol.value = '0.5'; } // ensure audible
    });

    metroVol.addEventListener('input', () => {
      const v = parseFloat(metroVol.value) || 0;
      try { api.metronomeVolume = v; } catch {}
      try { localStorage.setItem('metroVol', String(v)); } catch {}
      metroToggle.checked = v > 0;
    });

    // tempo
    const debouncedRender = debounce((bpm) => renderScoreWithBpm(bpm), 150);
    tempoVal.textContent = tempoSlider.value;
    tempoSlider.addEventListener('input', () => {
      const bpm = parseInt(tempoSlider.value,10) || STATE.currentBpm;
      tempoVal.textContent = bpm;
      api.playbackSpeed = 1.0;
      debouncedRender(bpm);
    });
    tempoSlider.addEventListener('change', () => tempoSlider.dataset.touched = '1');

    // opacity
    opacityVal.textContent = parseFloat(opacitySlider.value).toFixed(2);
    opacitySlider.addEventListener('input', () => {
      STATE.normalNoteDimFactor = parseFloat(opacitySlider.value) || 0;
      opacityVal.textContent = STATE.normalNoteDimFactor.toFixed(2);
      if (STATE.USE_INLINE_COLORING && api.score) { colorScoreByPitch(api.score); api.render(); }
    });

    // layout paddings
    const applyLayoutPadding = () => {
      try {
        const s = api.settings;
        if (!s?.display) return;
        if (chordSpace) {
          const vTop = parseInt(chordSpace.value,10) || 0;
          s.display.effectStaffPaddingBottom = vTop;
          s.display.notationStaffPaddingTop = Math.max(0, Math.round(vTop * 0.8));
          chordVal.textContent = `${vTop}px`;
        }
        if (dynSpace) {
          const vBot = parseInt(dynSpace.value,10) || 0;
          s.display.effectStaffPaddingTop = vBot;
          s.display.notationStaffPaddingBottom = Math.max(0, Math.round(vBot * 0.875));
          dynVal.textContent = `${vBot}px`;
        }
        api.updateSettings(s); api.render();
      } catch (e) { console.warn('applyLayoutPadding failed:', e); }
    };
    chordSpace.addEventListener('input', applyLayoutPadding);
    dynSpace.addEventListener('input', applyLayoutPadding);

    // HSV + assist
    const refreshStaticHlUI = () => {
      hlHVal.textContent = hlH.value; hlSVal.textContent = hlS.value; hlVVal.textContent = hlV.value;
      setHighlightColor(getStaticHlHex());
    };
    refreshStaticHlUI();
    [hlH,hlS,hlV].forEach(sl => sl.addEventListener('input', refreshStaticHlUI));

    hlAssist.addEventListener('change', () => {
      setBuiltinHighlighting(hlAssist.checked);
      setHighlightColor(getStaticHlHex());
    });

    // transport
    btnPlay.onclick = () => { 
      api.playPause(); 
      clearHighlightedNote();
    };
    btnStop.onclick = () => api.stop();

    
    

    // transpose UI
    reflectTransposeUI(STATE.transposeSemis);
    if (tDown)  tDown.addEventListener('click', () => applyNotationTranspose(clampSemis((STATE.transposeSemis||0) - 1)));
    if (tUp)    tUp.addEventListener('click', () => applyNotationTranspose(clampSemis((STATE.transposeSemis||0) + 1)));
    if (tReset) tReset.addEventListener('click', () => applyNotationTranspose(0));

    if (keySigToggle){
      keySigToggle.checked = STATE.keySigOn;
      keySigToggle.addEventListener('change', () => {
        STATE.keySigOn = keySigToggle.checked;
        try { localStorage.setItem('keySigToggle', STATE.keySigOn ? '1' : '0'); } catch {}
        applyNotationTranspose(STATE.transposeSemis);
      });
    }
    if (enhToggle){
      enhToggle.checked = STATE.preferFlats;
      enhToggle.addEventListener('change', () => {
        STATE.preferFlats = enhToggle.checked;
        try { localStorage.setItem('enhPreferFlats', STATE.preferFlats ? '1' : '0'); } catch {}
        applyNotationTranspose(STATE.transposeSemis);
      });
    }

    /* =========================
       AlphaTab events
       ========================= */
    api.error.on(err => {
      console.error('[AlphaTab error]', err);
      try { status.textContent = 'AlphaTab error: ' + (err?.message || err); } catch {}
    });

    api.soundFontLoad.on(e => {
      const pct = Math.floor((e.loaded / e.total) * 100);
      status.textContent = `Loading soundfont… ${pct}%`;
    });

    api.playerReady.on(() => {
      status.textContent = 'Ready';
      btnStop.disabled = false;
      btnPlay.disabled = false;
      applyLoopUI(loadLoopPref());
      // Re-apply SF and metronome to be safe after player ready
      if (sfSelect) applySoundFontChoice(sfSelect.value || 'local');
      try { api.metronomeVolume = parseFloat(localStorage.getItem('metroVol') || '0') || 0; } catch {}
    });

    // tick cache warm
    api.midiLoad.on(() => { STATE.tickCacheReady = true; if (STATE.pendingAccentOnWarm && api?.player?.state === alphaTab.synth.PlayerState.Playing) { STATE.pendingAccentOnWarm = false; accentAtCurrentTick(); } });
    api.midiLoaded.on(() => { STATE.tickCacheReady = true; if (STATE.pendingAccentOnWarm && api?.player?.state === alphaTab.synth.PlayerState.Playing) { STATE.pendingAccentOnWarm = false; accentAtCurrentTick(); } });

    api.playerStateChanged.on(e => {
      const playing = e.state === alphaTab.synth.PlayerState.Playing;
      btnPlay.textContent = playing ? 'Pause' : 'Play';
      if (playing) {
        if (STATE.customLoopEnabled && STATE.loopStartTick != null) ensureSeekToLoopStart();
        if (STATE.tickCacheReady) {
          STATE.tickHint = null;
          accentAtCurrentTick();
        } else {
          STATE.pendingAccentOnWarm = true;
        }
      } else {
        STATE.pendingAccentOnWarm = false;
      }
      updateDebug('state:'+e.state);
    });

    api.playerPositionChanged.on(e => {
      pos.textContent = `${fmtTime(e.currentTime)} / ${fmtTime(e.endTime)}`;
      updateDebug();
      if (STATE.customLoopEnabled && STATE.loopStartTick != null && STATE.loopEndTick != null) {
        const ct = typeof e.currentTick === 'number' ? e.currentTick : null;
        if (ct != null && ct >= (STATE.loopEndTick - STATE.LOOP_SEEK_EARLY_TICKS)) {
          ensureSeekToLoopStart();
        }
      }
      // inline accent coloring
      if (!STATE.USE_INLINE_COLORING || !STATE.tickCacheReady) return;
      const tick = e?.currentTick;
      const cache = api.tickCache;
      if (!cache || typeof tick !== 'number') return;
      const res = cache.findBeat(getTrackSet(), tick, STATE.tickHint);
      if (!res) return; STATE.tickHint = res;
      const beat = res.beat; if (!beat) return;
      const scoreBeat = (beat.notes ? beat : findBeatInScore(api.score, beat)) || beat;
      if (STATE.lastBeatAccented === scoreBeat) return;
      if (STATE.lastBeatAccented) recolorBeat(STATE.lastBeatAccented);
      accentBeat(scoreBeat);
      STATE.lastBeatAccented = scoreBeat;
      try { api.render(); } catch {}
    });

    api.playerStateChanged.on(e => {
      if (e.state !== alphaTab.synth.PlayerState.Playing) {
        STATE.pendingAccentOnWarm = false;
        if (STATE.lastBeatAccented) {
          recolorBeat(STATE.lastBeatAccented);
          STATE.lastBeatAccented = null;
          STATE.tickHint = null;
          try { api.render(); } catch {}
        }
      }
    });

    api.scoreLoaded.on(score => {
      applyDarkNotationalStyles(api.score, STATE.isDark);
      if (STATE.USE_INLINE_COLORING) colorScoreByPitch(api.score);
      setHighlightColor(getStaticHlHex());
      setBuiltinHighlighting(hlAssist.checked);
      if (!tempoSlider.dataset.touched) { tempoSlider.value = STATE.currentBpm; tempoVal.textContent = STATE.currentBpm; }
      try {
        const s = api.settings?.display || {};
        if (Number.isFinite(s.effectStaffPaddingBottom)) { chordSpace.value = String(s.effectStaffPaddingBottom); chordVal.textContent = s.effectStaffPaddingBottom + 'px'; }
        if (Number.isFinite(s.effectStaffPaddingTop)) { dynSpace.value = String(s.effectStaffPaddingTop); dynVal.textContent = s.effectStaffPaddingTop + 'px'; }
      } catch {}
      STATE.tickCacheReady = false; STATE.tickHint = null;
      const prewarm = () => { try { api.loadMidiForScore(); } catch(_) {} };
      if (api.isReadyForPlayback) prewarm(); else { const once = () => { api.playerReady.off(once); prewarm(); }; api.playerReady.on(once); }
      // Loop: handled via playbackRange now
      // apply current transpose to both audio + display (and key if enabled)
      applyNotationTranspose(STATE.transposeSemis);
      api.render();
      updateDebug('scoreLoaded');
      highlightNotesList = [];
        for (const track of score.tracks)
          for (const staff of track.staves)
            for (const bar of staff.bars)
              for (const voice of bar.voices)
                for (const beat of voice.beats)
                  for (const note of beat.notes || []) {
                    highlightNotesList.push({ note, beat });
                  }
        highlightedNoteIdx = -1;
    });
  // Clear the highlighted note
    function clearHighlightedNote() {
  // Remove accent from previously highlighted beat
  if (highlightedNoteIdx >= 0 && highlightNotesList[highlightedNoteIdx]) {
    const { beat } = highlightNotesList[highlightedNoteIdx];
    if (beat) recolorBeat(beat); // revert to normal color+opacity
  }
  highlightedNoteIdx = -1;
  try { api.render(); } catch {}
}

function highlightNoteAt(idx) {
  clearHighlightedNote();
  if (highlightNotesList.length === 0) return;
  highlightedNoteIdx = ((idx % highlightNotesList.length) + highlightNotesList.length) % highlightNotesList.length;
  const { note, beat } = highlightNotesList[highlightedNoteIdx];
  if (!note) return;
  accentBeat(beat); // Use your existing accentBeat logic for full highlight
  try { api.render(); } catch {}
}

 
    // MIDI-driven highlight color when assist is ON
    try {
      if (api.midiEventsPlayed && 'midiEventsPlayedFilter' in api && alphaTab?.midi?.MidiEventType) {
        api.midiEventsPlayedFilter = [alphaTab.midi.MidiEventType.NoteOn];
        api.midiEventsPlayed.on(e => { if (!hlAssist.checked) return; // only when assist active
          // color by top midi pitch of the batch
          let best = null;
          for (const ev of e.events || []) {
            const type = ev.type || ev.eventType || ev.kind;
            const isNoteOn = type === alphaTab?.midi?.MidiEventType?.NoteOn || ev.isNoteOn;
            if (!isNoteOn) continue;
            const n = ev.note ?? ev.noteNumber ?? ev.key ?? ev.data1;
            if (typeof n !== 'number') continue;
            if (best == null || n > best) best = n;
          }
          if (best != null) setHighlightColor(pcColor(best));
        });
      }
    } catch {}

    // Play/pause helpers
    const accentAtCurrentTick = () => {
      if (!STATE.USE_INLINE_COLORING) return;
      if (!STATE.tickCacheReady) return;
      const cache = api.tickCache;
      const tick = typeof api.tickPosition === 'number' ? api.tickPosition : undefined;
      if (!cache || typeof tick !== 'number') return;
      const res = cache.findBeat(getTrackSet(), tick, STATE.tickHint);
      if (!res || !res.beat) return;
      STATE.tickHint = res;
      const b = res.beat;
      const scoreBeat = (b.notes ? b : findBeatInScore(api.score, b)) || b;
      if (STATE.lastBeatAccented && STATE.lastBeatAccented !== scoreBeat) recolorBeat(STATE.lastBeatAccented);
      accentBeat(scoreBeat);
      STATE.lastBeatAccented = scoreBeat;
      api.render();
    };

    // First render after fonts are ready
    Promise.all([
      document.fonts.load("16px 'MuseJazzText'"),
      document.fonts.load("16px 'MuseJazz'")
    ]).catch(() => {}).finally(() => {
      renderScoreWithBpm(STATE.currentBpm);
      setHighlightColor(getStaticHlHex());
    });
  })();
  </script>
</body>